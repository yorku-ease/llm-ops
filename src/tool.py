from __future__ import annotations
from dataclasses import dataclass
from typing import Callable
from langchain_core.tools import tool, BaseTool

# Lets investigate if there are any libraries that could make tool construction easier for us
# Then we make toolbox. Tool calls are generated by model, converted to format toolbox expects,
# sent to toolbox, toolbox generates dict of {f_name: response}, pass this back to model, final output is sent out
# option for printing out tool calls made
# maybe llmfunction holds history of actions



# really an angent is just a tool
# but i suppose one agent might converse with another
# so we need some abstraction that allows us to offer functionality to the llm
# base class should include prompt we need to add to the llm's system prompt to let it know that it can use these tools


# TODO: We can use pydantic to handle checking for us
# If we restrict use of the function through the tool class we can change logic easily
# Really any types that are more complex than builtin types should be dataclasses.
# If we use pydantics tojson functionality we can accept dicts of builtin types and 
# convert in our code
# TODO: PARAM DESCRIPTINOS
# TODO: FROM DOCSTRING


# All tool inputs require: Function, description of function, description and type of arguments
@dataclass
class Tool:
    """Fn must have type annotations for any arguments"""
    name: str
    description: str
    fn: Callable
    _tool: BaseTool
    
    @property
    def arg_types(self):
        return {
            arg_name: type 
            for arg_name, type in self.fn.__annotations__.items() 
            if arg_name != "return"
        }

    @property
    def args_schema(self):
        """Returns dict containing description and type information about function arguments"""
        return self._tool.args
    
    def __call__(self, **kwargs): # TODO: we might wanna use a dict here because thats the format well be getting function calls in from llms
        # we might not even wanna check argument types
        # but we can check them and also if argumetns without defaults are missing with signature.inspect
        return self.fn(**kwargs)
    
    @classmethod
    def from_fn(cls, fn: Callable) -> Tool:
        """Creates a Tool from a function with a google-style docstring.

        A google style docstring looks like this, containing an args and 
        results section exactly as below. These sections are used to generate
        the descriptions and types of the arguments, which are passed to models
        so they can understand how to use tools

        Args:
            fn (Callable): The function to use as a Tool.
        
        Returns:
            Tool: A tool that can be used by LLMs 
        """
        return tool(parse_docstring=True)(fn)

@dataclass
class ToolCall:
    name: str
    params: dict[str, str]

def handle_tool_call(tool, tool_call):
    # cast arguments to correct types
    tool_arg_types = tool.arg_types
    fn_args = {}
    for param, value in tool_call.params.items():
        fn_args[param] = tool_arg_types[param](value)
    
    return tool(**fn_args)


def get_tool_outputs(tools: list[Tool], tool_calls: list[ToolCall]):
    name_to_tool = {t.name: t for t in tools}
    outputs = {}
    for tc in tool_calls:
        appropriate_tool = name_to_tool.get(tc.name)
        if appropriate_tool is None:
            raise ValueError(f"Tool call {tc} attempting to call tool that does not exist: {tc.name}")
        outputs[appropriate_tool.name] = handle_tool_call(appropriate_tool, tc)
    
    return outputs